Module(body=[
    ImportFrom(module='dataclasses', names=[
        alias(name='dataclass', asname=None),
      ], level=0),
    Import(names=[
        alias(name='ipaddress', asname=None),
      ]),
    Import(names=[
        alias(name='typing', asname=None),
      ]),
    Import(names=[
        alias(name='functools', asname=None),
      ]),
    ImportFrom(module='protocol.command_builders', names=[
        alias(name='build_get_request', asname=None),
        alias(name='build_set_request', asname=None),
      ], level=2),
    ImportFrom(module=None, names=[
        alias(name='interfaces', asname=None),
      ], level=2),
    ImportFrom(module='transporter.token', names=[
        alias(name='Token', asname=None),
      ], level=2),
    ImportFrom(module='protocol.fields.data_types', names=[
        alias(name='*', asname=None),
      ], level=2),
    ImportFrom(module='protocol.fields.field', names=[
        alias(name='XmpField', asname=None),
      ], level=2),
    ImportFrom(module='registry', names=[
        alias(name='register_command', asname=None),
      ], level=2),
    ImportFrom(module='enums', names=[
        alias(name='*', asname=None),
      ], level=1),
    ImportFrom(module=None, names=[
        alias(name='subtypes', asname=None),
      ], level=1),
    ClassDef(name='P_RESERVATION', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    You set this command to reserve, release, or relinquish a port. The port must\n    be reserved before any of its configuration can be changed, including streams,\n    filters, capture, and datasets.The owner of the session must already have been\n    specified. Reservation will fail if the chassis or module is reserved to other\n    users.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=102, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='operation', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='ReservedAction', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='status', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='ReservedStatus', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the reservation status of the test port.\n\n        :return: the reservation status of the test port.\n        :rtype: ReservedStatus\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='operation', annotation=Name(id='ReservedAction', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the reservation of the test port, i.e., reserve, release, or relinquish.\n\n        :param operation: the reservation of the test port, i.e., reserve, release, or relinquish.\n        :type operation: ReservedAction\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='operation', value=Name(id='operation', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_release', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='ReservedAction', ctx=Load()), attr='RELEASE', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Release the port from your ownership.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_reserve', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='ReservedAction', ctx=Load()), attr='RESERVE', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Reserve the port.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_relinquish', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='ReservedAction', ctx=Load()), attr='RELINQUISH', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value="Release the port from others' ownership.\n    ", kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_RESERVEDBY', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Identify the user who has a port reserved. The empty string if the port is not\n    currently reserved. Note that multiple connections can specify the same name\n    with C_OWNER, but a resource can only be reserved to one connection. Therefore\n    you cannot count on having the port just because it is reserved in your name.\n    The port is reserved to this connection only if P_RESERVATION returns\n    RESERVED_BY_YOU.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=103, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='username', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpStr', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpStr', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the username of the user who has the port reserved.\n\n        :return: the username of the user who has the port reserved.\n        :rtype: P_RESERVEDBY.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_RESET', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Reset port-level parameters to standard values, and delete all streams, filters,\n    capture, and dataset definitions.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=104, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            Pass(),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Reset the port to its default configuration.\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_CAPABILITIES', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    A series of integer values specifying various internal limits of a port.\n    integer: integer, internally defined limit values.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=106, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='max_speed', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_speed_reduction', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='min_interframe_gap', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_interframe_gap', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_preamble', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_streams_per_port', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_percent', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_pps', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_mbps', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_seed', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_tx_packet_limit', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_burst_size', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='min_packet_length', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_packet_length', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_header_length', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_protocol_segments', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_pattern_length', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_modifiers', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_modifier_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_repeat', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_tpid', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_manual_packets', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_match_terms', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_length_terms', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_ors', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_nots', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_filters', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_captured_packets', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_tpld_stats', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_histogram', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_32bit_modifiers', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_set_autoneg', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_tcp_checksum', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_udp_checksum', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_eee', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_hw_reg_access', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_tcvr_mii_reg_access', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_adv_phy_man', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_micro_tpld', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_mdi_mdix', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_payload_mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_custom_data_fields', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_ext_payload', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_dyn_traffic_change', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_sync_traffic_start', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_pfc', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_pcs_pma_config', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_fec', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpUnsignedInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpUnsignedInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_fec_stats', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_tx_eq', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_rx_retune', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='prbs_types_supported', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='prbs_invertions_supported', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='prbs_polys_supported', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIntList5', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIntList5', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='serdes_count', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='lane_count', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='tx_eq_tap_count', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='tx_eq_tap_max_val', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIntList10', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIntList10', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='tx_eq_tap_min_val', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIntList10', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIntList10', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_fec_correctable_symbol_count', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='max_xmit_one_packet_length', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='tx_runt_packet_min_length', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='rx_runt_packet_min_length', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_manipulate_preamble', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_set_link_train', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_link_flap', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_auto_neg_base_r', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='can_pma_error_pulse', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='is_chimera', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='has_p2p_loop_partner', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='p2p_loop_partner', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the internal limits, aka. capabilities, of the port.\n\n        :return: the internal limits, aka. capabilities, of the port.\n        :rtype: P_CAPABILITIES.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_INTERFACE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Obtains the name of the physical interface type of a port.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=107, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='interface', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpStr', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpStr', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the name of the physical interface type of a port.\n\n        :return: the name of the physical interface type of a port.\n        :rtype: P_INTERFACE.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_SPEEDSELECTION', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    The speed mode of an autoneg port with an interface type supporting multiple speeds.\n\n    .. note::\n    \n        This is only a settable command when speed is selected at the port level. Use the :class:`~xoa_driver.internals.core.commands.m_commands.M_CFPCONFIG` command when speed is selected at the module level.\n\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=109, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='PortSpeedMode', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='PortSpeedMode', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the speed mode of the port with an interface type supporting multiple speeds.\n\n        :return: the speed mode of the port with an interface type supporting multiple speeds.\n        :rtype: P_SPEEDSELECTION.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='mode', annotation=Name(id='PortSpeedMode', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the speed mode of the port with an interface type supporting multiple speeds.\n\n        :param mode: the speed mode of the port with an interface type supporting multiple speeds\n        :type mode: PortSpeedMode\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='mode', value=Name(id='mode', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_auto', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PortSpeedMode', ctx=Load()), attr='AUTO', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the speed mode to auto (all speeds used in auto negotiation).\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_f10m', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PortSpeedMode', ctx=Load()), attr='F10M', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the speed mode to 10 Mbit/s.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_f100m', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PortSpeedMode', ctx=Load()), attr='F100M', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the speed mode to 100 Mbit/s.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_f1g', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PortSpeedMode', ctx=Load()), attr='F1G', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the speed mode to 1 Gbit/s.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_f10g', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PortSpeedMode', ctx=Load()), attr='F10G', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the speed mode to 10 Gbit/s.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_f40g', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PortSpeedMode', ctx=Load()), attr='F40G', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the speed mode to 40 Gbit/s.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_f100g', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PortSpeedMode', ctx=Load()), attr='F100G', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the speed mode to 100 Gbit/s.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_f10mhdx', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PortSpeedMode', ctx=Load()), attr='F10MHDX', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the speed mode to 10 Mbit/s Half Duplex.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_f100mhdx', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PortSpeedMode', ctx=Load()), attr='F100MHDX', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the speed mode to 100 Mbit/s Half Duplex.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_f10m100m', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PortSpeedMode', ctx=Load()), attr='F10M100M', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the speed mode to 10/100 Mbit/s.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_f100m1g', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PortSpeedMode', ctx=Load()), attr='F100M1G', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the speed mode to 100 Mbit/s / 1 Gbit/s.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_f100m1g10g', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PortSpeedMode', ctx=Load()), attr='F100M1G10G', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the speed mode to 100 Mbit/s / 1 Gbit/s / 10 Gbit/s.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_f2500m', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PortSpeedMode', ctx=Load()), attr='F2500M', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the speed mode to 2500 Mbit/s.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_f5g', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PortSpeedMode', ctx=Load()), attr='F5G', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the speed mode to 5 Gbit/s.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_f100m1g2500m', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PortSpeedMode', ctx=Load()), attr='F100M1G2500M', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the speed mode to 100 Mbit/s / 1 Gbit/s / 2500 Mbit/s.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_unknown', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PortSpeedMode', ctx=Load()), attr='UNKNOWN', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the speed mode to unknown.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_SPEED', bases=[], keywords=[], body=[
        Expr(value=Constant(value="\n    Obtains the current physical speed of a port's interface.\n    ", kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=110, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='port_speed', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Get the current physical speed of the port's interface.\n\n        :return: the current physical speed of the port's interface.\n        :rtype: P_SPEED.GetDataAttr\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_RECEIVESYNC', bases=[], keywords=[], body=[
        Expr(value=Constant(value="\n    Obtains the current in-sync status of a port's receive interface.\n    ", kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=111, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='sync_status', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='SyncStatus', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Get the current in-sync status for a port's receive interface.\n\n        :return: the current in-sync status for a port's receive interface.\n        :rtype: P_RECEIVESYNC.GetDataAttr\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_COMMENT', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    The description of a port.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=112, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='comment', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpStr', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpStr', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='comment', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpStr', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpStr', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the description of the port.\n\n        :return: the description of the port\n        :rtype: P_COMMENT.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='comment', annotation=Name(id='str', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the description of the port.\n\n        :param comment: the description of the port\n        :type comment: str\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='comment', value=Name(id='comment', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_SPEEDREDUCTION', bases=[], keywords=[], body=[
        Expr(value=Constant(value="\n    A speed reduction applied to the transmitting side of a port, resulting in an\n    effective traffic rate that is slightly lower than the rate of the physical\n    interface. Speed reduction is effectuated by inserting short idle periods in the\n    generated traffic pattern to consume part of the port's physical bandwidth. The\n    port's clock speed is not altered.\n    ", kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=113, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='ppm', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='ppm', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the speed reduction ppm value of the test port.\n\n        :return: the speed reduction ppm value of the test port.\n        :rtype: P_SPEEDREDUCTION.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='ppm', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the speed reduction ppm value of the test port. \n\n        :param ppm: the speed reduction ppm value of the test port\n        :type ppm: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='ppm', value=Name(id='ppm', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_INTERFRAMEGAP', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    The mimimum gap between packets in the traffic generated for a port. The gap\n    includes the Ethernet preamble.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=114, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='min_byte_count', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='min_byte_count', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the mimimum gap between packets in the traffic generated for a port. The gap includes the Ethernet preamble. \n\n        :return: the mimimum gap between packets in the traffic generated for a port. The gap includes the Ethernet preamble.\n        :rtype: P_INTERFRAMEGAP.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='min_byte_count', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the mimimum gap between packets in the traffic generated for a port. The gap includes the Ethernet preamble. \n\n        :param min_byte_count: the mimimum gap between packets in the traffic generated for a port. The gap includes the Ethernet preamble.\n        :type min_byte_count: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='min_byte_count', value=Name(id='min_byte_count', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_MACADDRESS', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    A 48-bit Ethernet MAC address specified for a port. This address is used as the\n    default source MAC field in the header of generated traffic for the port, and is\n    also used for support of the ARP protocol.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=116, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mac_address', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpMacAddress', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpMacAddress', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mac_address', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpMacAddress', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpMacAddress', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the MAC address of the port.\n\n        :return: the MAC address of the port.\n        :rtype: P_MACADDRESS.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='mac_address', annotation=Name(id='str', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the MAC address of the port.\n\n        :param mac_address: the MAC address of the port\n        :type mac_address: str\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='mac_address', value=Name(id='mac_address', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_IPADDRESS', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    An IPv4 network configuration specified for a port. The address is used as the\n    default source address field in the IP header of generated traffic, and the\n    configuration is also used for support of the ARP and PING protocols.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=117, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='ipv4_address', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV4Address', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV4Address', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='subnet_mask', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV4Address', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV4Address', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='gateway', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV4Address', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV4Address', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='wild', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV4Address', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV4Address', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='ipv4_address', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV4Address', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV4Address', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='subnet_mask', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV4Address', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV4Address', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='gateway', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV4Address', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV4Address', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='wild', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV4Address', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV4Address', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the IPv4 address, subnet mask, gateway address and wildcard used for ARP and PING replies of the port.\n\n        :return: the IPv4 address, subnet mask, gateway address and wildcard used for ARP and PING replies of the port\n        :rtype: P_IPADDRESS.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='ipv4_address', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[
                Name(id='str', ctx=Load()),
                Name(id='int', ctx=Load()),
                Attribute(value=Name(id='ipaddress', ctx=Load()), attr='IPv4Address', ctx=Load()),
              ], ctx=Load()), ctx=Load()), type_comment=None),
            arg(arg='subnet_mask', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[
                Name(id='str', ctx=Load()),
                Name(id='int', ctx=Load()),
                Attribute(value=Name(id='ipaddress', ctx=Load()), attr='IPv4Address', ctx=Load()),
              ], ctx=Load()), ctx=Load()), type_comment=None),
            arg(arg='gateway', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[
                Name(id='str', ctx=Load()),
                Name(id='int', ctx=Load()),
                Attribute(value=Name(id='ipaddress', ctx=Load()), attr='IPv4Address', ctx=Load()),
              ], ctx=Load()), ctx=Load()), type_comment=None),
            arg(arg='wild', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[
                Name(id='str', ctx=Load()),
                Name(id='int', ctx=Load()),
                Attribute(value=Name(id='ipaddress', ctx=Load()), attr='IPv4Address', ctx=Load()),
              ], ctx=Load()), ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the IPv4 address, subnet mask, gateway address and wildcard used for ARP and PING replies of the port.\n\n        :param ipv4_address: the IPv4 address of the port\n        :type ipv4_address: Union[str, int, ipaddress.IPv4Address]\n        :param subnet_mask: the subnet mask of the local network segment for the port\n        :type subnet_mask: Union[str, int, ipaddress.IPv4Address]\n        :param gateway: he gateway of the local network segment for the port\n        :type gateway: Union[str, int, ipaddress.IPv4Address]\n        :param wild: wildcards used for ARP and PING replies, and each byte must be 255 (0xFF) or 0 (0x00)\n        :type wild: Union[str, int, ipaddress.IPv4Address]\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='ipv4_address', value=Name(id='ipv4_address', ctx=Load())),
                    keyword(arg='subnet_mask', value=Name(id='subnet_mask', ctx=Load())),
                    keyword(arg='gateway', value=Name(id='gateway', ctx=Load())),
                    keyword(arg='wild', value=Name(id='wild', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_ARPREPLY', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Whether the port replies to ARP requests. The\n    port can reply to incoming ARP requests by mapping the IP address specified for\n    the port to the MAC address specified for the port. ARP/NDP reply generation is\n    independent of whether traffic and capture is on for the port.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=118, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the status of whether the port replies to ARP requests.\n\n        :return: the status of whether the port replies to ARP requests\n        :rtype: P_ARPREPLY.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='on_off', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the status of whether the port replies to ARP requests.\n\n        :param on_off: whether the port replies to ARP requests\n        :type on_off: OnOff\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='on_off', value=Name(id='on_off', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='OFF', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Disable the port from replying to incoming ARP requests.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='ON', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Enable the port to reply to incoming ARP requests.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_PINGREPLY', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Whether the port replies to IPv4/IPv6 PING. The port can\n    reply to incoming IPv4/IPv6 PING requests to the IP address specified for the port. IPv4/IPv6 PING\n    reply generation is independent of whether traffic and capture is on for the\n    port.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=119, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the status of whether the port replies to IPv4/IPv6 PING requests.\n\n        :return: the status of whether the port replies to IPv4/IPv6 PING requests\n        :rtype: P_PINGREPLY.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='on_off', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the status of whether the port replies to IPv4/IPv6 PING requests.\n\n        :param on_off: whether the port replies to IPv4/IPv6 PING requests\n        :type on_off: OnOff\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='on_off', value=Name(id='on_off', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='OFF', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Enable IPv4/IPv6 PING reply on the port.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='ON', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Enable IPv4/IPv6 PING reply on the port.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_PAUSE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Whether a port responds to incoming Ethernet PAUSE frames by holding back outgoing traffic.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=120, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the status of whether the port responds to incoming Ethernet PAUSE frames by holding back outgoing traffic.\n\n        :return: the status of whether the port responds to incoming Ethernet PAUSE frames by holding back outgoing traffic.\n        :rtype: P_PAUSE.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='on_off', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the status of whether the port responds to incoming Ethernet PAUSE frames by holding back outgoing traffic.\n\n        :param on_off: the status of whether the port responds to incoming Ethernet PAUSE frames by holding back outgoing traffic.\n        :type on_off: OnOff\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='on_off', value=Name(id='on_off', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='OFF', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Disable the port to respond to incoming Ethernet PAUSE frames.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='ON', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Enable the port to respond to incoming Ethernet PAUSE frames.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_RANDOMSEED', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    A fixed seed value specified for a port. This value is used for a pseudo-random\n    number generator used when generating traffic that requires random variation in\n    packet length, payload, or modified fields. As long as no part of the port\n    configuration is changed, the generated traffic patterns are reproducible when\n    restarting traffic for the port. A specified seed value of -1 instead creates\n    variation by using a new time-based seed value each time traffic generation is\n    restarted.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=121, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='seed', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='seed', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the seed value specified for the port.\n\n        :return: the seed value specified for the port.\n        :rtype: P_RANDOMSEED.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='seed', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the seed value for the port.\n\n        :param seed: the seed value for the port\n        :type seed: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='seed', value=Name(id='seed', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_LOOPBACK', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    The loopback mode for a port. Ports can be configured to perform two different\n    kinds of loopback: 1) External RX-to-TX loopback, where the received packets\n    are re-transmitted immediately. The packets are still processed by the receive\n    logic, and can be captured and analysed. 2) Internal TX-to-RX loopback, where\n    the transmitted packets are received directly by the port itself. This is mainly\n    useful for testing the generated traffic patterns before actual use.\n\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=122, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='LoopbackMode', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='LoopbackMode', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the loop back mode of the port.\n\n        :return: the loop back mode of the port.\n        :rtype: P_LOOPBACK.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='mode', annotation=Name(id='LoopbackMode', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the loop back mode of the port.\n\n        :param mode: the loop back mode of the port\n        :type mode: LoopMode\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='mode', value=Name(id='mode', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_none', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='LoopbackMode', ctx=Load()), attr='NONE', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the port loop back mode to non-looped.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_l1rx2tx', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='LoopbackMode', ctx=Load()), attr='L1RX2TX', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the port loop back mode to L1RX2TX, transmit byte-by-byte copy of the incoming packet.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_l2rx2tx', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='LoopbackMode', ctx=Load()), attr='L2RX2TX', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the port loop back mode to L2RX2TX, swap source and destination MAC addresses.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_l3rx2tx', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='LoopbackMode', ctx=Load()), attr='L3RX2TX', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the port loop back mode to L3RX2TX, swap source and destination MAC addresses and swap source and destination IP addresses.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_txon2rx', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='LoopbackMode', ctx=Load()), attr='TXON2RX', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the port loop back mode to TXON2RX, packet is also transmitted from the port.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_txoff2rx', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='LoopbackMode', ctx=Load()), attr='TXOFF2RX', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the port loop back mode to TXOFF2RX, port transmitter is off.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_port2port', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='LoopbackMode', ctx=Load()), attr='PORT2PORT', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the port loop back mode to PORT2PORT, packets received on one port is sent out again on the neighbor port for inline monitoring.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_FLASH', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Make the test port LED for a particular port flash on and off with a 1-second\n    interval. This is helpful when you need to identify a specific port within a\n    chassis.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=123, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the status of the LED flashing status of the port.\n\n        :return: the status of the LED flashing status of the port.\n        :rtype: P_FLASH.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='on_off', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the status of the LED flashing status of the port. \n\n        :param on_off: the status of the LED flashing status of the port.\n        :type on_off: OnOff\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='on_off', value=Name(id='on_off', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='OFF', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Disable port LED from flashing.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='ON', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Enable port LED to flash.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_TRAFFIC', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Whether a port is transmitting packets. When on, the port generates a sequence\n    of packets with contributions from each stream that is enabled. The streams are\n    configured using the PS_xxx parameters.\n    \n    .. note::\n    \n        From Release 57.1, if any of the specified packet sizes cannot fit into the packet generator, this command will return FAILED and not start the traffic. While traffic is on the streams for this port cannot be enabled or disabled, and the configuration of those streams that are enabled cannot be changed.\n\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=124, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='StartOrStop', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='TrafficOnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the traffic generation status of the port.\n\n        :return: the traffic generation status of the port\n        :rtype: P_TRAFFIC.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='on_off', annotation=Name(id='StartOrStop', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the traffic generation status of the port. \n\n        :param on_off: the traffic generation status of the port.\n        :type on_off: StartOrStop\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='on_off', value=Name(id='on_off', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_stop', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='StartOrStop', ctx=Load()), attr='STOP', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Stop the traffic generation of the port.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_start', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='StartOrStop', ctx=Load()), attr='START', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Start the traffic generation of the port.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_CAPTURE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Whether a port is capturing packets. When on, the port retains the received\n    packets and makes them available for inspection. The capture criteria are\n    configured using the PC_xxxparameters. While capture is on the capture\n    parameters cannot be changed.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=125, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='StartOrStop', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get whether the port is capturing packets.\n\n        :return: whether the port is capturing packets.\n        :rtype: P_CAPTURE.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='on_off', annotation=Name(id='StartOrStop', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set whether the port is capturing packets.\n\n        :param on_off: whether the port is capturing packets.\n        :type on_off: StartOrStop\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='on_off', value=Name(id='on_off', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_stop', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='StartOrStop', ctx=Load()), attr='STOP', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Stop packet capturing on the port.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_start', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='StartOrStop', ctx=Load()), attr='START', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Start packet capturing on the port.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_XMITONE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Transmits a single packet from a port, independent of the stream definitions,\n    and independent of whether traffic is on. A valid Frame Check Sum is written\n    into the final four bytes.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=126, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='hex_data', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpHexList', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpHexList', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='hex_data', annotation=Name(id='str', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Transmits a single packet from a port, independent of the stream definitions, and independent of whether traffic is on. A valid Frame Check Sum is written into the final four bytes. \n\n        :param hex_data: raw bytes of the packet in hex to transmit\n        :rtype: List[str]\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='hex_data', value=Name(id='hex_data', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_LATENCYOFFSET', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    An offset applied to the latency measurements performed for received traffic\n    containing test payloads. This value affects the minimum, average, and maximum\n    latency values obtained through the PR_TPLDLATENCY command.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=127, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='offset', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='offset', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the port latency offset value in nanoseconds.\n\n        :return: the port latency offset value in nanoseconds\n        :rtype: P_LATENCYOFFSET.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='offset', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the port latency offset value in nanoseconds.\n\n        :param offset: the port latency offset value in nanoseconds\n        :type offset: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='offset', value=Name(id='offset', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_LATENCYMODE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Latency is measured by inserting a time-stamp in each packet when it is\n    transmitted, and relating it to the time when the packet is received. There are\n    four separate modes for calculating the latency:\n\n        1)  Last-bit-out to last-bit-in, which measures basic bit-transit time, \n            independent of packet length. \n        2)  First-bit-out to last-bit-in, which adds the time taken to transmit the \n            packet itself.\n        3)  Last-bit-out to first-bit-in, which subtracts the time taken to transmit the\n            packet itself. The same latency mode must be configured for the transmitting\n            port and the receiving port; otherwise invalid measurements will occur.\n        4)  First-bit-out to first-bit-in, which adds the time taken to transmit the \n            packet itself, and subtracts the time taken to transmit the packet itself. \n            The same latency mode must be configured for the transmitting\n            port and the receiving port; otherwise invalid measurements will occur.\n\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=128, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='LatencyMode', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='LatencyMode', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the latency measurement mode of the port.\n\n        :return: the latency measurement mode of the port\n        :rtype: P_LATENCYMODE.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='mode', annotation=Name(id='LatencyMode', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the latency measurement mode of the port. \n\n        :param mode: the latency measurement mode of the port\n        :type mode: LatencyMode\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='mode', value=Name(id='mode', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_last2last', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='LatencyMode', ctx=Load()), attr='LAST2LAST', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the port latency mode to LAST2LAST (Last-bit-out to last-bit-in, which measures basic bit-transit time, independent of packet length).\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_first2last', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='LatencyMode', ctx=Load()), attr='FIRST2LAST', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the port latency mode to FIRST2LAST (First-bit-out to last-bit-in, which adds the time taken to transmit the packet itself).\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_last2first', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='LatencyMode', ctx=Load()), attr='LAST2FIRST', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the port latency mode to LAST2FIRST (Last-bit-out to first-bit-in, which subtracts the time taken to transmit the packet itself. The same latency mode must be configured for the transmitting port and the receiving port; otherwise invalid measurements will occur).\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_first2first', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='LatencyMode', ctx=Load()), attr='FIRST2FIRST', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the port latency mode to FIRST2FIRST (First-bit-out to first-bit-in, which adds the time taken to transmit the packet itself, and subtracts the time taken to transmit the packet itself. The same latency mode must be configured for the transmitting port and the receiving port; otherwise invalid measurements will occur).\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_AUTOTRAIN', bases=[], keywords=[], body=[
        Expr(value=Constant(value="\n    The interval between sending out training packets, allowing a switch to learn\n    the port's MAC address. Layer-2 switches configure themselves automatically by\n    detecting the source MAC addresses of packets received on each port. If a port\n    only receives, and does not itself transmit test traffic, then the switch will\n    never learn its MAC address. Also, if transmission is very rare the switch will\n    age-out the learned MAC address. By setting the auto-train interval you instruct\n    the port to send switch training packets, independent of whether the port is\n    transmitting test traffic.\n    ", kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=129, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='interval', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='interval', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the interval between sending out training packets of the port in seconds.\n\n        :return: the interval between sending out training packets of the port.\n        :rtype: P_AUTOTRAIN.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='interval', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the interval between sending out training packets of the port in seconds.\n\n        :param interval: the interval between sending out training packets of the port\n        :type interval: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='interval', value=Name(id='interval', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_UAT_MODE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    This command defines if a port is currently used by test suite Valkyrie1564, which\n    means that UAT (UnAvailable Time) will be detected for the port.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=138, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='delay', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='delay', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the state of the affected stream counters and time in milliseconds to wait before detection of UAT is started. Default value: 500. This command is ignored when state is set to OFF.\n\n        :return: the state of the affected stream counters and time in milliseconds to wait before detection of UAT is started. Default value: 500. This command is ignored when state is set to OFF.\n        :rtype: P_UAT_MODE.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='mode', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
            arg(arg='delay', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the UAT mode of the port. \n\n        :param mode: the state of the affected stream counters\n        :type mode: OnOff\n        :param delay: time in milliseconds to wait before detection of UAT is started. Default value: 500. This command is ignored when state is set to OFF\n        :type delay: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='mode', value=Name(id='mode', ctx=Load())),
                    keyword(arg='delay', value=Name(id='delay', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='OFF', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Disable UAT on the port.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='ON', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Enable UAT on the port.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_UAT_FLR', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    This command defines the threshold for the Frame Loss Ratio, where a second is\n    declared as a Severely Errored Second (SES). In Valkyrie1564 UnAvailable Time\n    (UAT) is declared after 10 consecutive SES has been detected\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=139, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='frame_loss_ratio', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='frame_loss_ratio', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the the threshold for the Frame Loss Ratio, where a second is declared as a Severely Errored Second (SES).\n\n        :return: specifies the Frame Loss Ratio threshold for SES as a fraction of 1 * 100 (i.e. if the threshold is 0.50, value is 50)\n        :rtype: P_UAT_FLR.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='frame_loss_ratio', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the the threshold for the Frame Loss Ratio, where a second is declared as a Severely Errored Second (SES). \n\n        :param frame_loss_ratio: Frame Loss Ratio specified as a number times 1/100, 0..100\n        :type frame_loss_ratio: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='frame_loss_ratio', value=Name(id='frame_loss_ratio', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_MIXWEIGHTS', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Allow changing the distribution of the MIX packet length by specifying the\n    percentage of each of the 16 possible frame sizes used in the MIX.  The sum of\n    the percentage values specified must be 100. The command will affect the mix-\n    distribution for all streams on the port. The possible 16 frame sizes are: 56\n    (not valid for 40G/100G), 60, 64, 70, 78, 92, 256, 496, 512, 570, 576, 594,\n    1438, 1518, 9216, and 16360.\n    \n    .. note::\n    \n        This command requires Xena server version 375 or higher.\n\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=192, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='weight_56_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_60_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_64_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_70_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_78_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_92_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_256_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_496_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_512_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_570_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_576_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_594_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_1438_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_1518_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_9216_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_16360_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='weight_56_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_60_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_64_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_70_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_78_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_92_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_256_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_496_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_512_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_570_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_576_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_594_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_1438_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_1518_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_9216_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='weight_16360_bytes', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the percentage of each of the \n        16 possible frame sizes used in the MIX. The sum of the percentage values specified must \n        be 100. The command will affect the mix-distribution for all streams on the port. \n        The possible 16 frame sizes are: 56 (not valid for 40G and above), 60, 64, 70, 78, 92, \n        256, 496, 512, 570, 576, 594, 1438, 1518, 9216, and 16360.\n\n        :return: the percentage of each of the 16 possible frame sizes used in the MIX. \n        :rtype: P_MIXWEIGHTS.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='weight_56_bytes', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='weight_60_bytes', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='weight_64_bytes', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='weight_70_bytes', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='weight_78_bytes', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='weight_92_bytes', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='weight_256_bytes', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='weight_496_bytes', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='weight_512_bytes', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='weight_570_bytes', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='weight_576_bytes', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='weight_594_bytes', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='weight_1438_bytes', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='weight_1518_bytes', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='weight_9216_bytes', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='weight_16360_bytes', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the percentage of each of the \n        16 possible frame sizes used in the MIX. The sum of the percentage values specified must \n        be 100. The command will affect the mix-distribution for all streams on the port. \n        The possible 16 frame sizes are: 56 (not valid for 40G and above), 60, 64, 70, 78, 92, \n        256, 496, 512, 570, 576, 594, 1438, 1518, 9216, and 16360.\n\n        :param weight_56_bytes: specifying the percentage of 56-byte frame sizes\n        :type weight_56_bytes: int\n        :param weight_60_bytes: specifying the percentage of 60-byte frame sizes\n        :type weight_60_bytes: int\n        :param weight_64_bytes: specifying the percentage of 64-byte frame sizes\n        :type weight_64_bytes: int\n        :param weight_70_bytes: specifying the percentage of 70-byte frame sizes\n        :type weight_70_bytes: int\n        :param weight_78_bytes: specifying the percentage of 78-byte frame sizes\n        :type weight_78_bytes: int\n        :param weight_92_bytes: specifying the percentage of 92-byte frame sizes\n        :type weight_92_bytes: int\n        :param weight_256_bytes: specifying the percentage of 256-byte frame sizes\n        :type weight_256_bytes: int\n        :param weight_496_bytes: specifying the percentage of 496-byte frame sizes\n        :type weight_496_bytes: int\n        :param weight_512_bytes: specifying the percentage of 512-byte frame sizes\n        :type weight_512_bytes: int\n        :param weight_570_bytes: specifying the percentage of 570-byte frame sizes\n        :type weight_570_bytes: int\n        :param weight_594_bytes: specifying the percentage of 594-byte frame sizes\n        :type weight_594_bytes: int\n        :param weight_1438_bytes: specifying the percentage of 1438-byte frame sizes\n        :type weight_1438_bytes: int\n        :param weight_1518_bytes: specifying the percentage of 1518-byte frame sizes\n        :type weight_1518_bytes: int\n        :param weight_9216_bytes: specifying the percentage of 9216-byte frame sizes\n        :type weight_9216_bytes: int\n        :param weight_16360_bytes: specifying the percentage of 16360-byte frame sizes\n        :type weight_16360_bytes: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='weight_56_bytes', value=Name(id='weight_56_bytes', ctx=Load())),
                    keyword(arg='weight_60_bytes', value=Name(id='weight_60_bytes', ctx=Load())),
                    keyword(arg='weight_64_bytes', value=Name(id='weight_64_bytes', ctx=Load())),
                    keyword(arg='weight_70_bytes', value=Name(id='weight_70_bytes', ctx=Load())),
                    keyword(arg='weight_78_bytes', value=Name(id='weight_78_bytes', ctx=Load())),
                    keyword(arg='weight_92_bytes', value=Name(id='weight_92_bytes', ctx=Load())),
                    keyword(arg='weight_256_bytes', value=Name(id='weight_256_bytes', ctx=Load())),
                    keyword(arg='weight_496_bytes', value=Name(id='weight_496_bytes', ctx=Load())),
                    keyword(arg='weight_512_bytes', value=Name(id='weight_512_bytes', ctx=Load())),
                    keyword(arg='weight_570_bytes', value=Name(id='weight_570_bytes', ctx=Load())),
                    keyword(arg='weight_576_bytes', value=Name(id='weight_576_bytes', ctx=Load())),
                    keyword(arg='weight_594_bytes', value=Name(id='weight_594_bytes', ctx=Load())),
                    keyword(arg='weight_1438_bytes', value=Name(id='weight_1438_bytes', ctx=Load())),
                    keyword(arg='weight_1518_bytes', value=Name(id='weight_1518_bytes', ctx=Load())),
                    keyword(arg='weight_9216_bytes', value=Name(id='weight_9216_bytes', ctx=Load())),
                    keyword(arg='weight_16360_bytes', value=Name(id='weight_16360_bytes', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_MDIXMODE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Selects the MDI/MDIX behaviour of copper interfaces (Currently supported on\n    M6SFP and M2SFPT).\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=194, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='MDIXMode', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='MDIXMode', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the MDI/MDIX mode of the port.\n\n        :return: the MDI/MDIX mode of the port.\n        :rtype: P_MDIXMODE.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='mode', annotation=Name(id='MDIXMode', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the MDI/MDIX mode of the port. \n\n        :param mode: the MDI/MDIX mode of the port.\n        :type mode: MDIXMode\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='mode', value=Name(id='mode', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_auto', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='MDIXMode', ctx=Load()), attr='AUTO', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the MDI/MDIX mode of the port to Auto.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_mdi', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='MDIXMode', ctx=Load()), attr='MDI', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the MDI/MDIX mode of the port to MDI.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_mdix', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='MDIXMode', ctx=Load()), attr='MDIX', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the MDI/MDIX mode of the port to MDIX.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_TRAFFICERR', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Obtain the traffic error which has occurred in the last ``*_TRAFFIC`` or ``C_TRAFFICSYNC`` command.\n\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=198, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='error', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='TrafficError', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get traffic error which has occurred in the last ``*_TRAFFIC`` or ``C_TRAFFICSYNC`` command.\n\n        :return: traffic error which has occurred in the last ``*_TRAFFIC`` or ``C_TRAFFICSYNC`` command\n        :rtype: P_TRAFFICERR.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_GAPMONITOR', bases=[], keywords=[], body=[
        Expr(value=Constant(value="\n    The gap-start and gap-stop criteria for the port's gap monitor. The gap monitor\n    expects a steady stream of incoming packets, and detects larger-than-allowed\n    gaps between them. Once a gap event is encountered it requires a certain number\n    of consecutive packets below the threshold to end the event.\n    ", kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=301, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='start', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='stop', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='start', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='stop', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Get the gap-start and gap-stop criteria for the port's gap monitor.\n\n        :return: the gap-start and gap-stop criteria for the port's gap monitor\n        :rtype: P_GAPMONITOR.GetDataAttr\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='start', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='stop', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Set the gap-start and gap-stop criteria for the port's gap monitor.\n        :param start: the maximum allowed gap between packets, in microseconds. (0 to 134.000 microseconds) 0 = disable gap monitor\n        :type start: int\n        :param stop: the minimum number of good packets required. (0 to 1024 packets) 0 = disable gap monitor\n        :type stop: int\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='start', value=Name(id='start', ctx=Load())),
                    keyword(arg='stop', value=Name(id='stop', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_CHECKSUM', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Controls an extra payload integrity checksum, which also covers the header\n    protocols following the Ethernet header. It will therefore catch any\n    modifications to the protocol fields (which should therefore not have modifiers\n    on them).\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=302, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='offset', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='offset', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the offset in the packet where the calculation of the extra checksum is started from. Set to OFF or 0 to disable. Valid enable range is [8 .. 127, ON]. Please observe that ON equals the value 14. Please also observe that P_CHECKSUM ? will return OFF if set to 0 (or OFF) and that P_CHECKSUM ? will return ON if set to 14 (or ON).\n\n        :return: the offset in the packet where the calculation of the extra checksum is started from\n        :rtype: P_CHECKSUM.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='offset', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the offset in the packet where the calculation of the extra checksum is started from. Set to OFF or 0 to disable. Valid enable range is [8 .. 127, ON]. \n        Please observe that ON equals the value 14. Please also observe that P_CHECKSUM ? will return OFF if set to 0 (or OFF) and that P_CHECKSUM ? will return ON if set to 14 (or ON). \n\n        :param offset:  the offset in the packet where the calculation of the extra checksum is started from\n        :type offset: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='offset', value=Name(id='offset', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Constant(value=0, kind=None),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value="Set port's payload checksum off (offset = 0).\n    ", kind=None)),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Constant(value=14, kind=None),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value="Set port's payload checksum on (offset = 14).\n    ", kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_STATUS', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Get the received signal level for optical ports.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=303, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='optical_power', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIntList', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIntList', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the received signal level for optical ports, in nanowatts, -1 when not available. \n\n        :return: the received signal level for optical ports, in nanowatts, -1 when not available\n        :rtype: P_STATUS.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_AUTONEGSELECTION', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Whether the port responds to incoming auto-negotiation requests. Only applicable\n    to electrical ports (RJ45).\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=304, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get whether the port responds to incoming auto-negotiation requests.\n\n        :return: whether the port responds to incoming auto-negotiation requests\n        :rtype: P_AUTONEGSELECTION.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='on_off', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set whether the port responds to incoming auto-negotiation requests.\n\n        :param on_off: whether the port responds to incoming auto-negotiation requests\n        :type on_off: OnOff\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='on_off', value=Name(id='on_off', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='OFF', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='ON', ctx=Load()),
          ], keywords=[]), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_MIXLENGTH', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Allows inspecting the frame sizes defined for each position of the P_MIXWEIGHTS\n    command.  By default, the 16 frame sizes are: 56 (not valid for 40G/100G), 60,\n    64, 70, 78, 92, 256, 496, 512, 570, 576, 594, 1438, 1518, 9216, and 16360.  In\n    addition to inspecting these sizes one by one, it also allows changing frame\n    size for positions 0, 1, 14 and 15 (default values 56, 60, 9216 and 16360).\n    Supported by the following modules: Thor-400G-7S-1P, Thor-100G-5S-4P and\n    Loki-100G-5S-2P.\n    \n    .. note::\n    \n        This command requires release 84 or higher.\n\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=305, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='position_xindex', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='frame_size', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='frame_size', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get frame sizes defined for each position of the P_MIXWEIGHTS command. \n        By default, the 16 frame sizes are: 56 (not valid for 40G/100G), 60,\n        64, 70, 78, 92, 256, 496, 512, 570, 576, 594, 1438, 1518, 9216, and 16360.\n\n        :return: frame sizes defined for each position of the P_MIXWEIGHTS command\n        :rtype: P_MIXLENGTH.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='indices', value=List(elts=[
                        Attribute(value=Name(id='self', ctx=Load()), attr='position_xindex', ctx=Load()),
                      ], ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='frame_size', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the frame size defined for positions 0, 1, 14 and 15 (default values 56, 60, 9216 and 16360), in bytes.\n\n        :param frame_size: the frame size for the position.\n        :type frame_size: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='indices', value=List(elts=[
                        Attribute(value=Name(id='self', ctx=Load()), attr='position_xindex', ctx=Load()),
                      ], ctx=Load())),
                    keyword(arg='frame_size', value=Name(id='frame_size', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_ARPRXTABLE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Port ARP table used to reply to incoming ARP requests.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=308, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='chunks', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Attribute(value=Name(id='subtypes', ctx=Load()), attr='ArpChunkList', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Attribute(value=Name(id='subtypes', ctx=Load()), attr='ArpChunkList', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='chunks', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Attribute(value=Name(id='subtypes', ctx=Load()), attr='ArpChunkList', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Attribute(value=Name(id='subtypes', ctx=Load()), attr='ArpChunkList', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Get the port's ARP table used to reply to incoming ARP requests.\n\n        :return: the port's ARP table used to reply to incoming ARP requests.\n            * IP address to match to the Target IP address in the ARP requests, \n            * The prefix used for address matching, \n            * Whether the target MAC address will be patched with the part of the IP address that is not masked by the prefix, \n            * The target MAC address to return in the ARP reply\n        :rtype: P_ARPRXTABLE.GetDataAttr\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='chunks', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='List', ctx=Load()), slice=Attribute(value=Name(id='subtypes', ctx=Load()), attr='ArpChunk', ctx=Load()), ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Set the port's ARP table used to reply to incoming ARP requests. \n\n        :param chunks: \n            * IP address to match to the Target IP address in the ARP requests\n            * The prefix used for address matching\n            * Whether the target MAC address will be patched with the part of the IP address that is not masked by the prefix\n            * The target MAC address to return in the ARP reply\n        :type chunks: List[subtypes.ArpChunkList]\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='chunks', value=Name(id='chunks', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_NDPRXTABLE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Port NDP table used to reply to incoming NDP Neighbor Solicitation.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=309, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='chunks', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Attribute(value=Name(id='subtypes', ctx=Load()), attr='NdpChunkList', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Attribute(value=Name(id='subtypes', ctx=Load()), attr='NdpChunkList', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='chunks', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Attribute(value=Name(id='subtypes', ctx=Load()), attr='NdpChunkList', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Attribute(value=Name(id='subtypes', ctx=Load()), attr='NdpChunkList', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Get the port's NDP table used to reply to incoming NDP Neighbor Solication.\n\n        :return: the port's NDP table used to reply to incoming NDP Neighbor Solication.\n            * IP address to match to the Target IP address in the NDP Neighbor Solication\n            * The prefix used for address matching\n            * Whether the target MAC address will be patched with the part of the IP address that is not masked by the prefix\n            * The target MAC address to return in the NDP Neighbor Advertisement\n        :rtype: P_NDPRXTABLE.GetDataAttr\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='chunks', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='List', ctx=Load()), slice=Attribute(value=Name(id='subtypes', ctx=Load()), attr='NdpChunk', ctx=Load()), ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Set the port's NDP table used to reply to incoming NDP Neighbor Solication.\n\n        :param chunks: \n            * IP address to match to the Target IP address in the NDP Neighbor Solication\n            * The prefix used for address matching\n            * Whether the target MAC address will be patched with the part of the IP address that is not masked by the prefix\n            * The target MAC address to return in the NDP Neighbor Advertisement\n        :type chunks: List[subtypes.NdpChunkList]\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='chunks', value=Name(id='chunks', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_MULTICAST', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    A multicast mode for a port. Ports can use the IGMPv2 protocol to join or leave\n    multicast groups, either on an on-off basis or repeatedly.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=311, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='ipv4_multicast_addresses', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV4AddressListStopToKeep4', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV4AddressListStopToKeep4', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='operation', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='MulticastOperation', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='second_count', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='ipv4_multicast_addresses', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV4AddressListStopToKeep4', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV4AddressListStopToKeep4', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='operation', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='MulticastOperation', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='second_count', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Get the port's multicast information (IGMPv2).\n\n        :return: the port's multicast information (IGMPv2)\n        :rtype: P_MULTICAST.GetDataAttr\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='ipv4_multicast_addresses', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='List', ctx=Load()), slice=Attribute(value=Name(id='ipaddress', ctx=Load()), attr='IPv4Address', ctx=Load()), ctx=Load()), type_comment=None),
            arg(arg='operation', annotation=Name(id='MulticastOperation', ctx=Load()), type_comment=None),
            arg(arg='second_count', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Set the port's multicast information (IGMPv2).\n\n        :param ipv4_multicast_addresses: a multicast group address to join or leave\n        :type ipv4_multicast_addresses: List[ipaddress.IPv4Address]\n        :param operation: the operation\n        :type operation: MulticastOperation\n        :param second_count: the interval between repeated joins in seconds.\n        :type second_count: int\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='ipv4_multicast_addresses', value=Name(id='ipv4_multicast_addresses', ctx=Load())),
                    keyword(arg='operation', value=Name(id='operation', ctx=Load())),
                    keyword(arg='second_count', value=Name(id='second_count', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
          ], keywords=[
            keyword(arg='operation', value=Attribute(value=Name(id='MulticastOperation', ctx=Load()), attr='OFF', ctx=Load())),
          ]), type_comment=None),
        Expr(value=Constant(value="Set port's multicast operation to Off.\n    ", kind=None)),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
          ], keywords=[
            keyword(arg='operation', value=Attribute(value=Name(id='MulticastOperation', ctx=Load()), attr='ON', ctx=Load())),
          ]), type_comment=None),
        Expr(value=Constant(value="Set port's multicast operation to On.\n    ", kind=None)),
        Assign(targets=[
            Name(id='set_join', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
          ], keywords=[
            keyword(arg='operation', value=Attribute(value=Name(id='MulticastOperation', ctx=Load()), attr='JOIN', ctx=Load())),
          ]), type_comment=None),
        Expr(value=Constant(value="Set port's multicast operation to Join.\n    ", kind=None)),
        Assign(targets=[
            Name(id='set_leave', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
          ], keywords=[
            keyword(arg='operation', value=Attribute(value=Name(id='MulticastOperation', ctx=Load()), attr='LEAVE', ctx=Load())),
          ]), type_comment=None),
        Expr(value=Constant(value="Set port's multicast operation to Join.\n    ", kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_MULTICASTEXT', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    A multicast mode for a port. Ports can use the IGMPv2/IGMPv3 protocol to join or\n    leave multicast groups, either on an on-off basis or repeatedly. ** Requires\n    software release 83.2 or higher\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=312, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='ipv4_multicast_addresses', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV4AddressListStopToKeep4', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV4AddressListStopToKeep4', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='operation', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='MulticastExtOperation', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='second_count', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='igmp_version', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='IGMPVersion', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='ipv4_multicast_addresses', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV4AddressListStopToKeep4', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV4AddressListStopToKeep4', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='operation', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='MulticastExtOperation', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='second_count', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='igmp_version', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='IGMPVersion', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Get the port's multicast information (IGMPv2/IGMPv3).\n\n        :return: the port's multicast information (IGMPv2/IGMPv3)\n        :rtype: P_MULTICASTEXT.GetDataAttr\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='ipv4_multicast_addresses', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='List', ctx=Load()), slice=Attribute(value=Name(id='ipaddress', ctx=Load()), attr='IPv4Address', ctx=Load()), ctx=Load()), type_comment=None),
            arg(arg='operation', annotation=Name(id='MulticastExtOperation', ctx=Load()), type_comment=None),
            arg(arg='second_count', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='igmp_version', annotation=Name(id='IGMPVersion', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Set the port's multicast information (IGMPv2/IGMPv3).\n\n        :param ipv4_multicast_addresses: a multicast group address to join or leave\n        :type ipv4_multicast_addresses: List[ipaddress.IPv4Address]\n        :param operation: the operation\n        :type operation: MulticastExtOperation\n        :param second_count: the interval between repeated joins in seconds.\n        :type second_count: int\n        :param igmp_version: IGMP version\n        :type igmp_version: IGMPVersion\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='ipv4_multicast_addresses', value=Name(id='ipv4_multicast_addresses', ctx=Load())),
                    keyword(arg='operation', value=Name(id='operation', ctx=Load())),
                    keyword(arg='second_count', value=Name(id='second_count', ctx=Load())),
                    keyword(arg='igmp_version', value=Name(id='igmp_version', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_MCSRCLIST', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Multicast source list of the port. Only valid if the IGMP protocol version is\n    IGMPv3 set by P_MULTICASTEXT.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=313, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='ipv4_addresses', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV4AddressList', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV4AddressList', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='ipv4_addresses', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV4AddressList', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV4AddressList', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the multicast source list of the port. Only valid if the IGMP protocol version is IGMPv3 set by P_MULTICASTEXT.\n\n        :return: the multicast source list of the port\n        :rtype: P_MCSRCLIST.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='ipv4_addresses', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='List', ctx=Load()), slice=Attribute(value=Name(id='ipaddress', ctx=Load()), attr='IPv4Address', ctx=Load()), ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the multicast source list of the port.\n\n        :param ipv4_addresses: the multicast source list of the port\n        :type ipv4_addresses: List[ipaddress.IPv4Address]\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='ipv4_addresses', value=Name(id='ipv4_addresses', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_TXMODE', bases=[], keywords=[], body=[
        Expr(value=Constant(value="\n    The scheduling mode for outgoing traffic from the port, specifying how multiple\n    logical streams are merged onto one physical port. There are four primary modes:\n    Normal Interleaved: The streams are treated independently, and are merged into a\n    combined traffic pattern for the port, which honors each stream's ideal packet\n    placements as well as possible. This is the default mode. Strict Uniform: This\n    is a slight variation of normal interleaved scheduling, which emphasizes strict\n    uniformity of the inter-packet-gaps as more important than hitting the stream\n    rates absolutely precisely. Sequential: Each stream in turn contribute one or\n    more packets, before continuing to the next stream, in a cyclical pattern. The\n    count of packets for each stream is obtained from the PS_PACKETLIMIT command\n    value for the stream. The individual rates for each stream are ignored, and\n    instead the overall rate is determined at the port-level. This in turn determines \n    the rates for each stream, taking into account their packet lengths and counts. \n    The maximum number of packets in a cycle (i.e. the sum of PS_PACKETLIMIT for all \n    enabled streams) is 500. If the packet number is larger than 500,  will be returned \n    when attempting to start the traffic (P_TRAFFIC ON). Burst*: When this mode is selected, \n    frames from the streams on a port are sent as bursts as depicted below:  \n    The Burst Period is defined in the P_TXBURSTPERIOD command. For the individual streams \n    the number of packets in a burst is defined by the PS_BURST command, while the Inter\n    Packet Gap and the Inter Burst Gap are defined by the PS_BURSTGAP command.\n    ", kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=320, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='TXMode', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='TXMode', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the scheduling mode for outgoing traffic from the port.\n\n        :return: the scheduling mode for outgoing traffic from the port, containing the loopback mode for the port: NORMAL (interleaved packet scheduling), STRICTUNIFORM (strict uniform mode), SEQUENTIAL (sequential packet scheduling), BURST (burst mode).\n        :rtype: P_TXMODE.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='mode', annotation=Name(id='TXMode', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the the scheduling mode for outgoing traffic from the port.\n\n        :param mode: the scheduling mode for outgoing traffic from the port, containing the loopback mode for the port: NORMAL (interleaved packet scheduling), STRICTUNIFORM (strict uniform mode), SEQUENTIAL (sequential packet scheduling), BURST (burst mode).\n        :type mode: LoopbackMode\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='mode', value=Name(id='mode', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_normal', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='TXMode', ctx=Load()), attr='NORMAL', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the port scheduling mode to Normal.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_strictuniform', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='TXMode', ctx=Load()), attr='STRICTUNIFORM', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the port scheduling mode to Strict Uniform.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_sequential', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='TXMode', ctx=Load()), attr='SEQUENTIAL', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the port scheduling mode to Sequential.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_burst', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='TXMode', ctx=Load()), attr='BURST', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the port scheduling mode to Burst.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_MULTICASTHDR', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Allows addition of a VLAN tag to IGMPv2 and IGPMv3 packets. This command\n    requires software release 83.2 or higher.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=314, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='header_count', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='header_format', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='MulticastHeaderFormat', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='tag', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='pcp', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='dei', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='header_count', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='header_format', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='MulticastHeaderFormat', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='tag', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='pcp', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='dei', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the VLAN tag to the IGMPv2 and IGMPv3 packets of the port.\n\n        :return: the VLAN tag to the IGMPv2 and IGMPv3 packets of the port\n        :rtype: P_MULTICASTHDR.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='header_count', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='header_format', annotation=Name(id='MulticastHeaderFormat', ctx=Load()), type_comment=None),
            arg(arg='tag', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='pcp', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='dei', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the VLAN tag to the IGMPv2 and IGMPv3 packets of the port.\n\n        :param header_count: number of additional headers. Currently only 0 or 1 supported\n        :type header_count: int\n        :param header_format: indicates the header format\n        :type header_format: HeaderFormat\n        :param tag: VLAN tag (VID)\n        :type tag: int\n        :param pcp: VLAN Priority code point\n        :type pcp: int\n        :param dei: drop-eligible indicator\n        :type dei: OnOff\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='header_count', value=Name(id='header_count', ctx=Load())),
                    keyword(arg='header_format', value=Name(id='header_format', ctx=Load())),
                    keyword(arg='tag', value=Name(id='tag', ctx=Load())),
                    keyword(arg='pcp', value=Name(id='pcp', ctx=Load())),
                    keyword(arg='dei', value=Name(id='dei', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_RATEFRACTION', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    The port-level rate of the traffic transmitted for a port in sequential tx mode,\n    expressed in millionths of the effective rate for the port. The bandwidth\n    consumption includes the inter-frame gaps, and does not depend on the length of\n    the packets for the streams.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=321, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='port_rate_ppm', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='port_rate_ppm', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in millionths of the effective rate for the port. \n\n        :return: the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in millionths of the effective rate for the port.\n        :rtype: P_RATEFRACTION.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='port_rate_ppm', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in millionths of the effective rate for the port.  \n\n        :param port_rate_ppm: the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in millionths of the effective rate for the port\n        :type port_rate_ppm: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='port_rate_ppm', value=Name(id='port_rate_ppm', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_RATEPPS', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    The port-level rate of the traffic transmitted for a port in sequential tx mode,\n    expressed in packets per second. The bandwidth consumption is heavily dependent\n    on the length of the packets generated for the streams, and also on the inter-\n    frame gap for the port.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=322, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='port_rate_pps', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='port_rate_pps', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in packets per second.\n\n        :return: the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in packets per second\n        :rtype: P_RATEPPS.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='port_rate_pps', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in packets per second.\n\n        :param port_rate_pps: the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in packets per second\n        :type port_rate_pps: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='port_rate_pps', value=Name(id='port_rate_pps', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_RATEL2BPS', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    The port-level rate of the traffic transmitted for a port in sequential tx mode,\n    expressed in units of bits per-second at layer-2, thus including the Ethernet\n    header but excluding the inter-frame gap. The bandwidth consumption is somewhat\n    dependent on the length of the packets generated for the stream, and also on the\n    inter-frame gap for the port.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=323, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='port_rate_bps', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpLong', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpLong', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='port_rate_bps', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpLong', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpLong', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in units of bits per-second at layer-2, thus including the Ethernet header but excluding the inter-frame gap.\n\n        :return: the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in units of bits per-second at layer-2, thus including the Ethernet header but excluding the inter-frame gap\n        :rtype: P_RATEL2BPS.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='port_rate_bps', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in units of bits per-second at layer-2, thus including the Ethernet header but excluding the inter-frame gap.\n\n        :param port_rate_bps: the port-level rate of the traffic transmitted for a port in sequential tx mode, expressed in units of bits per-second at layer-2, thus including the Ethernet header but excluding the inter-frame gap\n        :type port_rate_bps: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='port_rate_bps', value=Name(id='port_rate_bps', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_PAYLOADMODE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Set this command to configure the port to use different payload modes, i.e.\n    normal, extend payload, and custom payload field, for ALL streams on this port.\n    The extended payload feature allows the definition of a much larger (up to MTU)\n    payload buffer for each stream. The custom payload field feature allows you to\n    define a sequence of custom data fields for each stream. The data fields will\n    then be used in a round robin fashion when packets are sent based on the stream\n    definition.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=324, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='PayloadMode', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='PayloadMode', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Get the port's payload mode, i.e. normal, extend payload, and custom payload field, for ALL streams on this port.\n\n        :return: the port's payload mode, i.e. normal, extend payload, and custom payload field, for ALL streams on this port.\n        :rtype: P_PAYLOADMOD.GetDataAttr\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='mode', annotation=Name(id='PayloadMode', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Set the port's payload mode, i.e. normal, extend payload, and custom payload field, for ALL streams on this port. \n\n        :param mode: the port's payload mode, i.e. normal, extend payload, and custom payload field, for ALL streams on this port\n        :type mode: PayloadMode\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='mode', value=Name(id='mode', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_normal', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PayloadMode', ctx=Load()), attr='NORMAL', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value="Set the port's payload mode to Normal.\n    ", kind=None)),
        Assign(targets=[
            Name(id='set_extpl', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PayloadMode', ctx=Load()), attr='EXTPL', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value="Set the port's payload mode to Extend Payload.\n    ", kind=None)),
        Assign(targets=[
            Name(id='set_cdf', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='PayloadMode', ctx=Load()), attr='CDF', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value="Set the port's payload mode to Custom Payload Field.\n    ", kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_BRRMODE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Selects the Master/Slave setting of 100 Mbit/s (requires Valkyrie release 76.1 or higher) and 1000 Mbit/s (requires Valkyrie release 76.2 or higher) BroadR-Reach copper interfaces.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=326, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='BRRMode', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='BRRMode', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Get the port's BroadR-Reach mode.\n\n        :return: the port's BroadR-Reach mode\n        :rtype: P_BRRMODE.GetDataAttr\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='mode', annotation=Name(id='BRRMode', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Set the port's BroadR-Reach mode.\n\n        :param mode: the port's BroadR-Reach mode\n        :type mode: BRRMode\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='mode', value=Name(id='mode', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_slave', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='BRRMode', ctx=Load()), attr='SLAVE', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value="Set the port's BRR mode to Slave.\n    ", kind=None)),
        Assign(targets=[
            Name(id='set_master', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='BRRMode', ctx=Load()), attr='MASTER', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value="Set the port's BRR mode to Master.\n    ", kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_TXENABLE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Whether a port should enable its transmitter, or keep the outgoing link down.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=327, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Get the port's transmitter status.\n\n        :return: the port's transmitter status\n        :rtype: P_TXENABLE.GetDataAttr\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='on_off', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Set the the port's transmitter status.\n\n        :param on_off: the port's transmiter status\n        :type on_off: OnOff\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='on_off', value=Name(id='on_off', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='OFF', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value="Disable the port's transmitter and keep the outgoing link down.\n    ", kind=None)),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='ON', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value="Enable the port's transmitter.\n    ", kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_MAXHEADERLENGTH', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    The maximum number of header content bytes that can be freely specified for each\n    generated stream. The remaining payload bytes of the packet are auto-\n    generated.The default is 128 bytes. When a larger number is select there is a\n    corresponding proportional reduction in the number of stream definitions that\n    are available for the port. Possible values: 128 (default), 256, 512, 1024,\n    2048.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=328, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='max_header_length', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='max_header_length', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the maximum number of header content bytes that can be freely specified for each generated stream on the port.\n\n        :return: the maximum number of header content bytes that can be freely specified for each generated stream on the port\n        :rtype: P_MAXHEADERLENGTH.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='max_header_length', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the maximum number of header content bytes that can be freely specified for each generated stream on the port. Possible values: 128 (default), 256, 512, 1024, 2048.\n\n        :param max_header_length: the maximum number of header content bytes that can be freely specified for each generated stream on the port\n        :type max_header_length: int.\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='max_header_length', value=Name(id='max_header_length', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_TXTIMELIMIT', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    A port-level time-limit on how long it keeps transmitting when started. After\n    the elapsed time traffic must be stopped and restarted. This complements the\n    stream-level PS_PACKETLIMIT function.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=329, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='microseconds', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpLong', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpLong', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='microseconds', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpLong', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpLong', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the port-level time-limit on how long it keeps transmitting when started in microseconds.\n\n        :return: port-level time-limit on how long it keeps transmitting when started in microseconds.\n        :rtype: P_TXTIMELIMIT.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='microseconds', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the port-level time-limit on how long it keeps transmitting when started in microseconds. Maximum can be 2^63.\n\n        :param microseconds: the port-level time-limit on how long it keeps transmitting when started in microseconds. Maximum can be 2^63\n        :type microseconds: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='microseconds', value=Name(id='microseconds', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_TXTIME', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    How long the port has been transmitting, the elapsed time since traffic was\n    started.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=330, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='microseconds', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpLong', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpLong', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get how long the port has been transmitting, the elapsed time since traffic was started in microseconds.\n\n        :return: how long the port has been transmitting, the elapsed time since traffic was started in microseconds\n        :rtype: P_TXTIME.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_XMITONETIME', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    The time at which the latest packet was transmitted using the P_XMITONE command.\n    The time reference is the same used by the time stamps of captured packets.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=331, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='nanoseconds', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpLong', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpLong', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the time at which the latest packet was transmitted using the P_XMITONE command in nanoseconds.\n\n        :return: the time at which the latest packet was transmitted using the P_XMITONE command in nanoseconds\n        :rtype: P_XMITONETIME.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_IPV6ADDRESS', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    An IPv6 network configuration specified for a port. The address is used as the\n    default source address field in the IP header of generated traffic, and the\n    configuration is also used for support of the NDP and PINGv6 protocols.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=332, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='ipv6_address', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV6Address', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV6Address', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='gateway', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV6Address', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV6Address', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='subnet_prefix', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='wildcard_prefix', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='ipv6_address', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV6Address', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV6Address', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='gateway', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIPV6Address', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIPV6Address', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='subnet_prefix', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='wildcard_prefix', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Get the port's IPv6 address settings.\n\n        :return: the port's IPv6 address settings\n        :rtype: P_IPV6ADDRESS.GetDataAttr\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='ipv6_address', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[
                Name(id='str', ctx=Load()),
                Name(id='int', ctx=Load()),
                Attribute(value=Name(id='ipaddress', ctx=Load()), attr='IPv6Address', ctx=Load()),
              ], ctx=Load()), ctx=Load()), type_comment=None),
            arg(arg='gateway', annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='Union', ctx=Load()), slice=Tuple(elts=[
                Name(id='str', ctx=Load()),
                Name(id='int', ctx=Load()),
                Attribute(value=Name(id='ipaddress', ctx=Load()), attr='IPv6Address', ctx=Load()),
              ], ctx=Load()), ctx=Load()), type_comment=None),
            arg(arg='subnet_prefix', annotation=Name(id='int', ctx=Load()), type_comment=None),
            arg(arg='wildcard_prefix', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Set the port's IPv6 settings.\n\n        :param ipv6_address: the IPv6 address of the port\n        :type ipv6_address: Union[str, int, ipaddress.IPv6Address]\n        :param gateway: the gateway of the local network segment for the port\n        :type gateway: Union[str, int, ipaddress.IPv6Address]\n        :param subnet_prefix: the subnet prefix of the local network segment for the port\n        :type subnet_prefix: int\n        :param wildcard_prefix: a prefix that makes the port replies to NDP/PING for the masked addresses, valid value 0-255\n        :type wildcard_prefix: int\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='ipv6_address', value=Name(id='ipv6_address', ctx=Load())),
                    keyword(arg='gateway', value=Name(id='gateway', ctx=Load())),
                    keyword(arg='subnet_prefix', value=Name(id='subnet_prefix', ctx=Load())),
                    keyword(arg='wildcard_prefix', value=Name(id='wildcard_prefix', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_ARPV6REPLY', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Whether the port generates replies using the IPv6 Network Discovery Protocol.\n    The port can reply to incoming NDP Neighbort Solications by mapping the IPv6 address\n    specified for the port to the MAC address specified for the port. NDP reply\n    generation is independent of whether traffic and capture is on for the port.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=333, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get whether the port replies to NDP Neighbor Solicitations.\n\n        :return: whether the port replies to NDP Neighbor Solicitations.\n        :rtype: P_ARPV6REPLY.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='on_off', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set whether the port replies to NDP Neighbor Solicitations. \n\n        :param on_off: whether the port replies to NDP Neighbor Solicitations. \n        :type on_off: OnOff\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='on_off', value=Name(id='on_off', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='OFF', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Disable the port from replying to NDP Neighbor Solicitations.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='ON', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Enable the port to reply to NDP Neighbor Solicitations.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_PINGV6REPLY', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Whether the port generates PINGv6 replies using the ICMP protocol received over\n    IPv6. The port can reply to incoming PINGv6 requests to the IPv6 address\n    specified for the port. PINGv6 reply generation is independent of whether\n    traffic and capture is on for the port.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=334, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get whether the port replies to incoming PINGv6.\n\n        :return: whether the port replies to incoming PINGv6\n        :rtype: P_PINGV6REPLY.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='on_off', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set whether the port replies to incoming PINGv6.\n\n        :param on_off: whether the port replies to incoming PINGv6. \n        :type on_off: OnOff\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='on_off', value=Name(id='on_off', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='OFF', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Disable the port from replying to PINGv6.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='ON', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Enable the port to reply to PINGv6.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_ERRORS', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Obtains the total number of errors detected across all streams on the port,\n    including lost packets, misorder events, and payload errors.\n    \n    .. note::\n    \n        FCS errors are included, which will typically lead to double-counting of lost packets.\n\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=335, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='error_count', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpLong', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpLong', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the total number of errors detected across all streams on the port, including lost packets, misorder events, and payload errors.\n\n        :return: the total number of errors detected across all streams on the port, including lost packets, misorder events, and payload errors\n        :rtype: P_ERRORS.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_TXPREPARE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Prepare port for transmission\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=336, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            Pass(),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the port to prepare for packet transmission.\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_TXDELAY', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Sets a variable delay from a traffic start command received by the port until\n    it starts transmitting. The delay is specified in multiples of 64 microseconds.\n    Valid values are 0-31250 (0 to 2.000.000 microseconds).\n    \n    .. note:: \n    \n        You must use :class:`~xoa_driver.internals.core.commands.c_commands.C_TRAFFIC` instead of :class:`~xoa_driver.internals.core.commands.p_commands.P_TRAFFIC` to start traffic for :class:`~xoa_driver.internals.core.commands.p_commands.P_TXDELAY` to have this effect.\n\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=337, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='delay_val', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='delay_val', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the delay from a traffic start command received by the port until the port starts transmitting packets, in microseconds.\n\n        :return: the delay from a traffic start command received by the port until the port starts transmitting packets, in microseconds.\n        :rtype: P_TXDELAY.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='delay_val', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the delay from a traffic start command received by the port until the port starts transmitting packets, in microseconds.\n\n        :param delay_val: the delay specified in multiples of 64 microseconds.\n        :type delay_val: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='delay_val', value=Name(id='delay_val', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_LPENABLE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Enables/disables Energy Efficient Ethernet (EEE) on the port.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=340, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get whether Energy Efficient Ethernet (EEE) is enabled on the port.\n\n        :return: whether Energy Efficient Ethernet (EEE) is enabled on the port\n        :rtype: P_LPENABLE.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='on_off', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set whether Energy Efficient Ethernet (EEE) is enabled on the port.\n\n        :param on_off: whether Energy Efficient Ethernet (EEE) is enabled on the port\n        :type on_off: OnOff\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='on_off', value=Name(id='on_off', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='OFF', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Disable Energy Efficient Ethernet (EEE) on the port.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='ON', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Enable Energy Efficient Ethernet (EEE) on the port.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_LPTXMODE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Enables/disables the transmission of Low Power Idles (LPIs) on the port. When\n    enabled, the transmit side of the port will automatically enter low-power mode\n    (and leave) low-power mode in periods of low or no traffic. LPIs will only be\n    transmitted if the Link Partner (receiving port) has advertised EEE capability\n    for the selected port speed during EEE auto-negotiation.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=341, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get whether the transmission of Low Power Idles (LPIs) is enabeld on the port.\n\n        :return: whether the transmission of Low Power Idles (LPIs) is enabeld on the port\n        :rtype: P_LPTXMODE.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='on_off', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set whether the transmission of Low Power Idles (LPIs) is enabeld on the port.\n\n        :param on_off: whether the transmission of Low Power Idles (LPIs) is enabeld on the port\n        :type on_off: OnOff\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='on_off', value=Name(id='on_off', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='OFF', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Disable the transmission of Low Power Idles (LPIs) on the port.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='ON', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Enable the transmission of Low Power Idles (LPIs) on the port.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_LPSTATUS', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Displays the Energy Efficient Ethernet (EEE) status as reported by the PHY.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=343, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='txh', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='TXHState', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='rxh', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='RXHState', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='txc', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='TXCState', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='rxc', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='RXCState', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='link_up', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='LinkState', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the the Energy Efficient Ethernet (EEE) status as reported by the PHY.\n            * if there has been any recent change in the EEE state on the transmission side\n            * if there has been any recent change in the EEE state on the receiver side\n            * the current EEE state of the transmitter\n            * the current EEE state of the receiver\n            * if the link is up\n\n        :return: the the Energy Efficient Ethernet (EEE) status\n        :rtype: P_LPSTATUS.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_LPPARTNERAUTONEG', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Displays the EEE capabilities advertised during autonegotiation by the far side\n    (link partner).\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=345, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='cap_100base_tx', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='YesNo', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cap_1000base_t', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='YesNo', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cap_10gbase_t', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='YesNo', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cap_100base_kx', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='YesNo', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cap_10gbase_kx4', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='YesNo', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cap_10gbase_kr', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='YesNo', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the the Energy Efficient Ethernet (EEE) capabilities advertised during autonegotiation by the far side (link partner).\n            * whether the link partner is capable of 100BASE-TX\n            * whether the link partner is capable of 1000BASE-T\n            * whether the link partner is capable of 10GBASE-T\n            * whether the link partner is capable of 100BASE-KX\n            * whether the link partner is capable of 10GBASE-KX4\n            * whether the link partner is capable of 10GBASE-KR\n\n        :return: the the Energy Efficient Ethernet (EEE) capabilities advertised during autonegotiation by the far side (link partner)\n        :rtype: P_LPPARTNERAUTONEG.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_LPSNRMARGIN', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Displays the SNR margin on the four link channels (Channel A-D) as reported by\n    the PHY. It is displayed in units of 0.1dB.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=346, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='channel_a', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='channel_b', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='channel_c', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='channel_d', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the SNR margin on the four link channels (Channel A-D) as reported by the PHY. It is displayed in units of 0.1dB.\n            * the SNR margin on link channel A\n            * the SNR margin on link channel B\n            * the SNR margin on link channel C\n            * the SNR margin on link channel D\n\n        :return: the SNR margin on the four link channels (Channel A-D) as reported by the PHY. It is displayed in units of 0.1dB\n        :rtype: P_LPSNRMARGIN.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_LPRXPOWER', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Obtain the RX power recorded during training for the four channels.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=347, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='channel_a', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='channel_b', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='channel_c', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='channel_d', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the the RX power recorded during training for the four channels.\n\n        :return: the the RX power recorded during training for the four channels\n            * the RX power on link channel A\n            * the RX power on link channel B\n            * the RX power on link channel C\n            * the RX power on link channel D\n        :rtype: P_LPRXPOWER.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_FAULTSIGNALING', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Sets the remote/local fault signaling behavior of the port (performed by the\n    Reconciliation Sub-layer). By default, the port acts according to the standard,\n    i.e. when receiving a bad signal, it transmits "Remote Fault indications"on the\n    output and when receiving a "Remote Fault indication"from the far-side it will\n    transmit IDLE sequences.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=348, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='fault_signaling', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='FaultSignaling', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='fault_signaling', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='FaultSignaling', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the remote/local fault signaling behavior of the port (performed by the Reconciliation Sub-layer).\n\n        :return: remote/local fault signaling behavior of the port\n        :rtype: P_FAULTSIGNALING.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='fault_signaling', annotation=Name(id='FaultSignaling', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the remote/local fault signaling behavior of the port (performed by the Reconciliation Sub-layer). \n\n        :param fault_signaling: remote/local fault signaling behavior of the port\n        :type fault_signaling: FaultSignaling\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='fault_signaling', value=Name(id='fault_signaling', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_normal', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='FaultSignaling', ctx=Load()), attr='NORMAL', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the remote/local fault signaling behavior of the port to Normal.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_force_local', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='FaultSignaling', ctx=Load()), attr='FORCE_LOCAL', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the remote/local fault signaling behavior of the port to Forced Local.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_force_remote', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='FaultSignaling', ctx=Load()), attr='FORCE_REMOTE', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the remote/local fault signaling behavior of the port to Forced Remote.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_disabled', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='FaultSignaling', ctx=Load()), attr='DISABLED', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Disable the remote/local fault signaling behavior of the port.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_FAULTSTATUS', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Shows if a local or remote fault is currently being detected by the\n    Reconciliation Sub-layer of the port.\n    \n    .. note::\n    \n        Currently only available on M1CFP100, M2CFP40, M2QSFP+ and M1CFP4QSFP28CXP.\n\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=349, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='local_fault_status', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='LocalFaultStatus', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='remote_fault_status', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='RemoteFaultStatus', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get whether a local or remote fault is currently being detected by the Reconciliation Sub-layer of the port.\n\n        :return: whether a local or remote fault is currently being detected.\n            * specifying the local fault\n            * specifying the remote fault\n        :rtype: P_FAULTSTATUS.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_TPLDMODE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Sets the size of the Xena Test Payload (TPLD) used to track streams, perform\n    latency measurements etc. Default is "Normal", which is a 20 byte TPLD. "Micro"\n    is a condensed version, which is useful when generating very small packets with\n    relatively long headers (like IPv6). It has the following characteristics\n    compared to the "normal" TPLD. When the TPLDMODE is changed, it will affect ALL\n    streams on the port. 1) Only 6 byte long. 2) Less accurate mechanism to separate\n    Xena-generated packets from other packets is the network - it is recommended not\n    to have too much other traffic going into the receive Xena port, when micro TPLD\n    is used. 3) No sequence checking (packet loss or packet misordering). The number\n    of received packets for each stream can still be compared to the number of\n    transmitted packets to detect packet loss once traffic has been stopped. Note:\n    Currently not available on M6SFP, M2SFPT, M6RJ45+/M2RJ45+, M2CFP40, M1CFP100,\n    M2SFP+4SFP\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=350, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='TPLDMode', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='mode', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='TPLDMode', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the Test Payload mode of the port.\n\n        :return: the Test Payload mode of the port\n        :rtype: P_TPLDMODE.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='mode', annotation=Name(id='TPLDMode', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the Test Payload mode of the port.\n\n        :param mode: the Test Payload mode of the port.\n        :type mode: TPLDMode\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='mode', value=Name(id='mode', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_normal', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='TPLDMode', ctx=Load()), attr='NORMAL', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the Test Payload mode of the port to Normal.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_micro', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='TPLDMode', ctx=Load()), attr='MICRO', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Set the Test Payload mode of the port to Micro.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_LPSUPPORT', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Read EEE capabilities of the port (variable size, one for each supported speed,\n    returns 0s if no EEE).\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=351, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='eee_capabilities', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpIntList', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpIntList', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the EEE capabilities of the port (variable size, one for each supported speed, returns 0s if no EEE).\n\n        :return: the EEE capabilities of the port (variable size, one for each supported speed, returns 0s if no EEE).\n        :rtype: P_LPSUPPORT.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_TXPACKETLIMIT', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    The number of packets that will be transmitted from a port when traffic is\n    started on the port. A value of 0 or -1 makes the port transmit continuously.\n    Traffic from the streams on the port can however also be set to stop after\n    transmitting a number of packets.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=352, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='packet_count_limit', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='packet_count_limit', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the number of packets that will be transmitted from the port when traffic is started on the port.\n\n        :return: the number of packets that will be transmitted from the port when traffic is started on the port.\n        :rtype: P_TXPACKETLIMIT.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='packet_count_limit', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the number of packets that will be transmitted from the port when traffic is started on the port.\n            A value of 0 or -1 makes the port transmit continuously. \n            Traffic from the streams on the port can however also be set to stop after transmitting a number of packets.\n\n        :param packet_count_limit: the number of packets that will be transmitted from the port when traffic is started on the port\n        :type packet_count_limit: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='packet_count_limit', value=Name(id='packet_count_limit', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_TCVRSTATUS', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Get various tcvr status information. RX loss status of the individual RX optical\n    lanes (only 4 lanes are supported currently).\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=357, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='rx_loss_lane_0', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='rx_loss_lane_1', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='rx_loss_lane_2', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='rx_loss_lane_3', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get various transceivre status information.\n\n        :return: various tcvr status information. RX loss status of the individual RX optical lanes (only 4 lanes are supported currently).\n        :rtype: P_TCVRSTATUS.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_DYNAMIC', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Controls if a >10G port supports dynamic changes when the traffic is\n    running. This command is only supported by ports >10G.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=368, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get whether the port should support dynamic changes when the traffic is running.\n\n        :return: whether the port should support dynamic changes when the traffic is running.\n        :rtype: P_DYNAMIC.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='on_off', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set whether the port should support dynamic changes when the traffic is running.\n\n        :param on_off: whether the port should support dynamic changes when the traffic is running\n        :type on_off: OnOff\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='on_off', value=Name(id='on_off', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='OFF', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Disable dynamic traffic change on the port.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='ON', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Enable dynamic traffic change on the port.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_PFCENABLE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    This setting control whether a port responds to incoming Ethernet Priority Flow\n    Control (PFC) frames, by holding back outgoing traffic for that priority.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=373, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='cos_0', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cos_1', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cos_2', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cos_3', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cos_4', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cos_5', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cos_6', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cos_7', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='cos_0', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cos_1', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cos_2', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cos_3', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cos_4', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cos_5', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cos_6', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
            AnnAssign(target=Name(id='cos_7', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get whether the port responds to incoming Ethernet Priority Flow Control (PFC) frames.\n\n        :return: whether PFC response is enabled for CoS 0, Cos 1, Cos 2, Cos 3, Cos 4, Cos 5, Cos 6, and Cos 7\n        :rtype: P_PFCENABLE.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='cos_0', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
            arg(arg='cos_1', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
            arg(arg='cos_2', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
            arg(arg='cos_3', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
            arg(arg='cos_4', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
            arg(arg='cos_5', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
            arg(arg='cos_6', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
            arg(arg='cos_7', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set whether the port responds to incoming Ethernet Priority Flow Control (PFC) frames.\n\n        :param cos_0: whether PFC response is enabled for CoS 0\n        :type cos_0: OnOff\n        :param cos_1: whether PFC response is enabled for CoS 1\n        :type cos_1: OnOff\n        :param cos_2: whether PFC response is enabled for CoS 2\n        :type cos_2: OnOff\n        :param cos_3: whether PFC response is enabled for CoS 3\n        :type cos_3: OnOff\n        :param cos_4: whether PFC response is enabled for CoS 4\n        :type cos_4: OnOff\n        :param cos_5: whether PFC response is enabled for CoS 5\n        :type cos_5: OnOff\n        :param cos_6: whether PFC response is enabled for CoS 6\n        :type cos_6: OnOff\n        :param cos_7: whether PFC response is enabled for CoS 7\n        :type cos_7: OnOff\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='cos_0', value=Name(id='cos_0', ctx=Load())),
                    keyword(arg='cos_1', value=Name(id='cos_1', ctx=Load())),
                    keyword(arg='cos_2', value=Name(id='cos_2', ctx=Load())),
                    keyword(arg='cos_3', value=Name(id='cos_3', ctx=Load())),
                    keyword(arg='cos_4', value=Name(id='cos_4', ctx=Load())),
                    keyword(arg='cos_5', value=Name(id='cos_5', ctx=Load())),
                    keyword(arg='cos_6', value=Name(id='cos_6', ctx=Load())),
                    keyword(arg='cos_7', value=Name(id='cos_7', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_TXBURSTPERIOD', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    In Burst TX mode this command defines the time from the start of one sequence of\n    bursts (from a number of streams) to the start of next sequence of bursts. NB:\n    Only used when Port TX Mode is "BURST".\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=377, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='burst_period', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpLong', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpLong', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='burst_period', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpLong', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpLong', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the duration in microseconds from the start of one sequence of bursts (from a number of streams) to the start of next sequence of bursts in Burst TX mode.\n\n        :return: the duration in microseconds from the start of one sequence of bursts (from a number of streams) to the start of next sequence of bursts\n        :rtype: P_TXBURSTPERIOD.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='burst_period', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the duration in microseconds from the start of one sequence of bursts (from a number of streams) to the start of next sequence of bursts in Burst TX mode.\n\n        :param burst_period: the duration in microseconds from the start of one sequence of bursts (from a number of streams) to the start of next sequence of bursts in Burst TX mode\n        :type burst_period: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='burst_period', value=Name(id='burst_period', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_TXRUNTLENGTH', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Enable TX runt feature to cut all packets to a number of bytes.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=390, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='runt_length', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='runt_length', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the TX runt feature to cut all packets to I bytes. -1 means disabled.\n\n        :return: the TX runt feature to cut all packets to I bytes\n        :rtype: P_TXRUNTLENGTH.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='runt_length', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set TX runt feature to cut all packets to I bytes. Set to -1 to disable.\n\n        :param runt_length: enable TX runt feature to cut all packets to I bytes. Set to -1 to disable.\n        :type runt_length: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='runt_length', value=Name(id='runt_length', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_RXRUNTLENGTH', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Enable RX runt length detection to flag if packets are seen with length not\n    being I bytes.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=391, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='runt_length', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='runt_length', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get RX runt length detection to flag if packets are seen with length not being I bytes. -1 means disabled.\n\n        :return: RX runt length detection to flag if packets are seen with length not being I bytes. -1 means disabled\n        :rtype: P_RXRUNTLENGTH.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='runt_length', annotation=Name(id='int', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set RX runt length detection to flag if packets are seen with length not being I bytes. Set to -1 to disabled.\n\n        :param runt_length: RX runt length detection to flag if packets are seen with length not being I bytes. Set to -1 to disabled.\n        :type runt_length: int\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='runt_length', value=Name(id='runt_length', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_RXRUNTLEN_ERRS', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Sticky clear on read: Have packets with wrong runt length been detected since last read?\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=392, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='status', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpInt', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpInt', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='YesNo', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Have packets with wrong runt length been detected since last read?\n\n        :return: whether packets with with wrong runt length been detected since last read\n        :rtype: P_RXRUNTLEN_ERRS.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_TXPREAMBLE_REMOVE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Remove preamble from outgoing frames.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=393, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get whether the preambles from outgoing frames are to be removed by the port.\n\n        :return: whether the preambles from outgoing frames are to be removed by the port\n        :rtype: P_TXPREAMBLE_REMOVE.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='on_off', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set whether the preambles from outgoing frames are to be removed by the port.\n\n        :param on_off: whether the preambles from outgoing frames are to be removed by the port\n        :type on_off: OnOff\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='on_off', value=Name(id='on_off', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='OFF', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Disable frame preameble removal on the port.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='ON', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Enable frame preameble removal on the port.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_RXPREAMBLE_INSERT', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Insert preambles to the incoming frames.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=394, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get whether the port should insert preambles to the incoming frames.\n\n        :return: whether the port should insert preambles to the incoming frames\n        :rtype: P_RXPREAMBLE_INSERT.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='on_off', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set whether the port should insert preambles to the incoming frames.\n\n        :param on_off: whether the port should insert preambles to the incoming frames\n        :type on_off: OnOff\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='on_off', value=Name(id='on_off', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='OFF', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Disable frame preameble insertion on the port.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='ON', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Enable frame preameble insertion on the port.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_LOADMODE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    The action determines if config load mode is enabled or disabled for the Chimera port.\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=395, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='on_off', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the status of config load mode of the Chimera port.\n\n        :return: the status of config load mode on the Chimera port\n        :rtype: P_LOADMODE.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='on_off', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Set the status of config load mode of the Chimera port.\n\n        :param on_off: whether config load is enabled on the Chimera port\n        :type on_off: OnOff\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='on_off', value=Name(id='on_off', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='OFF', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Disable config load on the Chimera port.\n    ', kind=None)),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='ON', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value='Enable config load on the Chimera port.\n    ', kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_SPEEDS_SUPPORTED', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    Read the speeds supported by the port. The speeds supported by a port depends on\n    the transceiver inserted into the port. A series of 0/1 values, identifying\n    which speeds are supported by the port. \n    \n    .. note::\n    \n        Ports can support zero (in case of e.g. empty cage), one, or multiple speeds.\n        \n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=396, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=False, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='auto', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f10M', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f100M', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f1G', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f10G', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f40G', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f100G', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f10MHDX', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f100MHDX', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f10M100M', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f100M1G', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f100M1G10G', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f2500M', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f5G', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f100M1G2500M', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f25G', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f50G', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f200G', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f400G', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f800G', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
            AnnAssign(target=Name(id='f1600G', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value='Get the speeds supported by the port.\n\n        :return: the speeds supported by the port\n        :rtype: P_SPEEDS_SUPPORTED.GetDataAttr\n        ', kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
    ClassDef(name='P_EMULATE', bases=[], keywords=[], body=[
        Expr(value=Constant(value='\n    The action determines if emulation functionality is enabled or disabled\n    ', kind=None)),
        AnnAssign(target=Name(id='code', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=1600, kind=None), simple=1),
        AnnAssign(target=Name(id='pushed', ctx=Store()), annotation=Subscript(value=Attribute(value=Name(id='typing', ctx=Load()), attr='ClassVar', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load()), value=Constant(value=True, kind=None), simple=1),
        AnnAssign(target=Name(id='_connection', ctx=Store()), annotation=Constant(value='interfaces.IConnection', kind=None), value=None, simple=1),
        AnnAssign(target=Name(id='_module', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        AnnAssign(target=Name(id='_port', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=None, simple=1),
        ClassDef(name='SetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='action', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        ClassDef(name='GetDataAttr', bases=[], keywords=[], body=[
            AnnAssign(target=Name(id='action', ctx=Store()), annotation=Subscript(value=Name(id='XmpField', ctx=Load()), slice=Name(id='XmpByte', ctx=Load()), ctx=Load()), value=Call(func=Name(id='XmpField', ctx=Load()), args=[
                Name(id='XmpByte', ctx=Load()),
              ], keywords=[
                keyword(arg='choices', value=Name(id='OnOff', ctx=Load())),
              ]), simple=1),
          ], decorator_list=[
            Call(func=Name(id='dataclass', ctx=Load()), args=[], keywords=[
                keyword(arg='frozen', value=Constant(value=True, kind=None)),
              ]),
          ]),
        FunctionDef(name='get', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Get whether the Chimera port's emulation functionality is enabled.\n\n        :return: whether the Chimera port's emulation functionality is enabled\n        :rtype: P_EMULATE.GetDataAttr\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_get_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token[GetDataAttr]', kind=None), type_comment=None),
        FunctionDef(name='set', args=arguments(posonlyargs=[], args=[
            arg(arg='self', annotation=None, type_comment=None),
            arg(arg='action', annotation=Name(id='OnOff', ctx=Load()), type_comment=None),
          ], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[
            Expr(value=Constant(value="Set whether the Chimera port's emulation functionality is enabled.\n\n        :param action: whether the Chimera port's emulation functionality is enabled\n        :type action: OnOff\n        ", kind=None)),
            Return(value=Call(func=Name(id='Token', ctx=Load()), args=[
                Attribute(value=Name(id='self', ctx=Load()), attr='_connection', ctx=Load()),
                Call(func=Name(id='build_set_request', ctx=Load()), args=[
                    Name(id='self', ctx=Load()),
                  ], keywords=[
                    keyword(arg='module', value=Attribute(value=Name(id='self', ctx=Load()), attr='_module', ctx=Load())),
                    keyword(arg='port', value=Attribute(value=Name(id='self', ctx=Load()), attr='_port', ctx=Load())),
                    keyword(arg='action', value=Name(id='action', ctx=Load())),
                  ]),
              ], keywords=[])),
          ], decorator_list=[], returns=Constant(value='Token', kind=None), type_comment=None),
        Assign(targets=[
            Name(id='set_off', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='OFF', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value="Disable the Chimera port's emulation functionality.\n    ", kind=None)),
        Assign(targets=[
            Name(id='set_on', ctx=Store()),
          ], value=Call(func=Attribute(value=Name(id='functools', ctx=Load()), attr='partialmethod', ctx=Load()), args=[
            Name(id='set', ctx=Load()),
            Attribute(value=Name(id='OnOff', ctx=Load()), attr='ON', ctx=Load()),
          ], keywords=[]), type_comment=None),
        Expr(value=Constant(value="Enable the Chimera port's emulation functionality.\n    ", kind=None)),
      ], decorator_list=[
        Name(id='register_command', ctx=Load()),
        Name(id='dataclass', ctx=Load()),
      ]),
  ], type_ignores=[])